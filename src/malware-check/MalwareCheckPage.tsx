import { useRouter } from 'next/router'
import { useEffect, useMemo, useState } from 'react'
import { api } from 'src/api-helper'
import { pointToString, RP } from 'src/crypto/curve'
import { decryptWithRandomizer } from 'src/crypto/decrypt'
import { CipherStrings } from 'src/crypto/stringify-shuffle'
import { Head } from 'src/Head'
import { unTruncateSelection } from 'src/status/un-truncate-selection'
import { useElectionInfo } from 'src/status/use-election-info'
import { TailwindPreflight } from 'src/TailwindPreflight'
import { generateColumnNames } from 'src/vote/generateColumnNames'
import { base64URLToBigint } from 'src/vote/submitted/base64url'

type CheckResult = {
  error?: string
  otp?: string
}

type VoteData = {
  decryptedPlaintext: Record<string, string> // questionId: plaintext
  randomizers: Record<string, string> // questionId -> randomizer (base64url)
}

export function MalwareCheckPage() {
  return (
    <div className="p-8 mx-auto max-w-2xl">
      <Head title="Malware Check" />
      <PageContent />
      <TailwindPreflight />
    </div>
  )
}

function PageContent() {
  const router = useRouter()
  const { auth_token, election_id } = router.query
  const [voteData, setVoteData] = useState<null | VoteData>(null)
  const [checkResult, setCheckResult] = useState<CheckResult | null>(null)
  const [confirmed, setConfirmed] = useState(false)
  const [issueDescription, setIssueDescription] = useState('')
  const [showIssueForm, setShowIssueForm] = useState(false)
  const { ballot_design, threshold_public_key } = useElectionInfo()

  // Extract randomizers from URL hash on page load
  useEffect(() => {
    if (typeof window === 'undefined' || !election_id || !auth_token) return

    const hash = window.location.hash.slice(1) // Remove #
    if (!hash) return setCheckResult({ error: 'Missing vote data in URL' })

    try {
      // Parse compact format: questionId|randomizer|questionId|randomizer|...
      const parts = hash.split('|')
      if (parts.length < 2 || parts.length % 2 !== 0) throw new Error('Invalid data format')

      const randomizers: Record<string, string> = {}

      // Process in pairs: questionId, randomizer
      for (let i = 0; i < parts.length; i += 2) {
        const questionId = parts[i]
        const randomizer = parts[i + 1]
        randomizers[questionId] = randomizer
      }

      const data: VoteData = { decryptedPlaintext: {}, randomizers }
      setVoteData(data)

      // Move private data into document memory and clear URL
      window.history.replaceState(null, '', window.location.pathname)
    } catch (_error) {
      setCheckResult({ error: 'Failed to parse vote data' })
      console.error('Failed to parse vote data', _error)
    }
  }, [election_id, auth_token])

  // Fetch encrypted vote, try to decrypt with randomizers, and send success/fail to server
  useEffect(() => {
    if (!voteData || !threshold_public_key || checkResult) return
    ;(async () => {
      try {
        if (!threshold_public_key) return setCheckResult({ error: 'Missing election public key' })

        const public_key = RP.fromHex(threshold_public_key)
        const { randomizers } = voteData

        if (!randomizers || Object.keys(randomizers).length === 0)
          return setCheckResult({ error: 'Invalid vote data format' })

        // Fetch encrypted vote from server
        const encryptedVoteResponse = await api(`/election/${election_id}/encrypted-vote?auth_token=${auth_token}`)
        if (!encryptedVoteResponse.ok) return setCheckResult({ error: 'Failed to fetch encrypted vote' })

        const { encrypted_vote } = (await encryptedVoteResponse.json()) as {
          encrypted_vote: Record<string, CipherStrings>
        }

        // Decrypt each cipher using the randomizer
        const decryptedPlaintext: Record<string, string> = {}

        for (const questionId of Object.keys(randomizers)) {
          const cipher = encrypted_vote[questionId]
          if (!cipher) return setCheckResult({ error: `Missing encrypted vote for question: ${questionId}` })

          // Convert base64url encoded randomizer back to bigint
          const randomizerBigInt = base64URLToBigint(randomizers[questionId])

          // Decrypt using randomizer and public key
          const decryptedPoint = decryptWithRandomizer(public_key, randomizerBigInt, {
            encrypted: RP.fromHex(cipher.encrypted),
            lock: RP.fromHex(cipher.lock),
          })

          // Extract plaintext from point (format: "verification_number:plaintext")
          const decodedString = pointToString(decryptedPoint)
          const colonIndex = decodedString.indexOf(':')
          if (colonIndex === -1) return setCheckResult({ error: `Invalid decoded format for question: ${questionId}` })

          const plaintext = decodedString.slice(colonIndex + 1)
          decryptedPlaintext[questionId] = plaintext
        }

        // Update voteData with decrypted plaintext
        setVoteData({ ...voteData, decryptedPlaintext })

        // Let server know we were able to decrypt the vote
        const response = await api('/malware-check', {
          auth_token,
          decrypted: true,
          election_id,
        })

        const result: CheckResult = await response.json()
        setCheckResult(result)
      } catch (error) {
        setCheckResult({ error: 'Failed to decrypt or verify vote' })
        console.error('Failed to decrypt or verify vote', error)
      }
    })()
  }, [voteData, threshold_public_key, election_id, auth_token, checkResult])

  const columns = useMemo(() => generateColumnNames({ ballot_design }).columns, [ballot_design])

  const handleConfirm = async (confirmed: boolean) => {
    try {
      const response = await api('/malware-check', {
        auth_token,
        confirmed,
        election_id,
        otp: checkResult?.otp,
      })

      if (!confirmed) return setShowIssueForm(true)

      if (response.ok) setConfirmed(true)
    } catch (error) {
      // Handle error
      console.error('Failed to report confirmation', error)
    }
  }

  const handleSubmitIssue = async () => {
    try {
      const response = await api('/malware-check', {
        auth_token,
        confirmed: false,
        election_id,
        issue_description: issueDescription,
        otp: checkResult?.otp,
      })

      if (response.ok) {
        setConfirmed(true)
        setShowIssueForm(false)
      }
    } catch (error) {
      // Handle error
      console.error('Failed to submit issue', error)
    }
  }

  if (!voteData || !ballot_design || !threshold_public_key)
    return (
      <div className="p-8 text-center">
        <p>Loading {!voteData ? 'vote data' : !ballot_design ? 'ballot design' : 'public key'}...</p>
      </div>
    )

  if (!voteData.decryptedPlaintext || Object.keys(voteData.decryptedPlaintext).length === 0) {
    return (
      <div className="p-8 text-center">
        <p>Decrypting vote...</p>
      </div>
    )
  }

  if (checkResult?.error)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-red-600">Error</h2>
        <p>{checkResult.error}</p>
      </div>
    )

  if (!checkResult)
    return (
      <div className="p-8 text-center">
        <p>Verifying your vote...</p>
      </div>
    )

  if (confirmed)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-green-600">Thank you</h2>
        <p>Your response has been recorded. You can now close this window.</p>
      </div>
    )

  if (!checkResult.otp)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-red-600">⚠️ Vote Mismatch Detected</h2>
        <p>
          This device is unable to decrypt your vote. <br />
          This may indicate malware on your original voting device.
        </p>
        <p className="my-4 font-bold">Please contact your election administrator.</p>
        <p>The SIV admin has also been notified about this issue.</p>
      </div>
    )

  // Show confirmation UI if match
  return (
    <div className="p-8 mx-auto max-w-2xl">
      <h2 className="mb-4 text-xl font-bold">Confirm your selections:</h2>

      <table className="mb-6 w-full border border-gray-300 border-collapse">
        <thead>
          <tr className="bg-gray-100">
            <th className="p-2 text-left border border-gray-300">Question</th>
            <th className="p-2 text-left border border-gray-300">Selection</th>
          </tr>
        </thead>
        <tbody>
          {columns.map((columnId) => {
            const plaintext = voteData.decryptedPlaintext?.[columnId]
            if (!plaintext) return null

            const displayValue = unTruncateSelection(plaintext, ballot_design || [], columnId)

            // Find question title from ballot design
            const question = ballot_design.find((item) => {
              if (item.id === columnId) return true
              // Handle multi-vote columns like "president_1", "president_2"
              const baseId = columnId.replace(/_\d+$/, '')
              return item.id === baseId
            })

            return (
              <tr key={columnId}>
                <td className="p-2 font-semibold border border-gray-300">{question?.title || columnId}</td>
                <td className="p-2 border border-gray-300">{plaintext === 'BLANK' ? '' : displayValue}</td>
              </tr>
            )
          })}
        </tbody>
      </table>

      {showIssueForm ? (
        <div className="mb-6">
          <label className="block mb-2 font-semibold">Please describe the issue:</label>
          <textarea
            className="p-2 w-full rounded border border-gray-300"
            onChange={(e) => setIssueDescription(e.target.value)}
            rows={4}
            value={issueDescription}
          />
          <button
            className="px-4 py-2 mt-2 text-white bg-blue-500 rounded hover:bg-blue-600"
            onClick={handleSubmitIssue}
          >
            Submit
          </button>
        </div>
      ) : (
        <div className="mb-6">
          <p className="mb-4">
            {Object.keys(columns).length === 1 ? 'Does this selection' : 'Do these selections'} match how you intended
            to vote?
          </p>
          <div className="flex gap-4">
            <button
              className="px-6 py-2 text-white bg-green-600 rounded hover:bg-green-700 active:bg-green-800"
              onClick={() => handleConfirm(true)}
            >
              Yes, match
            </button>
            <button
              className="px-6 py-2 text-white bg-red-600 rounded hover:bg-red-700 active:bg-red-800"
              onClick={() => handleConfirm(false)}
            >
              No, something is wrong
            </button>
          </div>
        </div>
      )}
    </div>
  )
}
