import { useRouter } from 'next/router'
import { useEffect, useMemo, useState } from 'react'
import { api } from 'src/api-helper'
import { RP, stringToPoint } from 'src/crypto/curve'
import encrypt from 'src/crypto/encrypt'
import { CipherStrings } from 'src/crypto/stringify-shuffle'
import { unTruncateSelection } from 'src/status/un-truncate-selection'
import { useElectionInfo } from 'src/status/use-election-info'
import { generateColumnNames } from 'src/vote/generateColumnNames'
import { base64URLToBigint } from 'src/vote/submitted/base64url'
import { decodePlaintext } from 'src/vote/submitted/encodePlaintext'

type CheckResult = {
  device_info?: string
  error?: string
  match: boolean
}

type VoteData = {
  randomizers: Record<string, string> // questionId -> randomizer (base64url)
  selections: Record<string, string> // questionId -> plaintext
  verificationNumber: string
}

export function MalwareCheckPage() {
  const router = useRouter()
  const { auth_token, election_id } = router.query
  const [voteData, setVoteData] = useState<null | VoteData>(null)
  const [checkResult, setCheckResult] = useState<CheckResult | null>(null)
  const [confirmed, setConfirmed] = useState(false)
  const [issueDescription, setIssueDescription] = useState('')
  const [showIssueForm, setShowIssueForm] = useState(false)
  const { ballot_design, threshold_public_key } = useElectionInfo()

  // Extract vote data from URL hash on page load
  useEffect(() => {
    if (typeof window === 'undefined' || !election_id || !auth_token) return

    const hash = window.location.hash.slice(1) // Remove #
    if (!hash) {
      setCheckResult({ error: 'Missing vote data in URL', match: false })
      return
    }

    try {
      // Parse compact format directly (no base64url decoding needed): tracking|questionId|plaintext|randomizer|questionId|plaintext|randomizer|...
      const parts = hash.split('|')
      if (parts.length < 1 || (parts.length - 1) % 3 !== 0) {
        throw new Error('Invalid data format')
      }

      // Decode verification number from base64url
      const verificationNumberBigInt = base64URLToBigint(parts[0])
      // Convert back to decimal string format (with dashes for display, but we'll use without dashes for encryption)
      const verificationNumber = verificationNumberBigInt.toString().padStart(12, '0')
      const selections: Record<string, string> = {}
      const randomizers: Record<string, string> = {}

      // Process in groups of 3: questionId, encodedPlaintext, randomizer
      // Note: We'll decode plaintext later when we have ballot_design
      for (let i = 1; i < parts.length; i += 3) {
        const questionId = parts[i]
        const encodedPlaintext = parts[i + 1]
        const randomizer = parts[i + 2]
        selections[questionId] = encodedPlaintext
        randomizers[questionId] = randomizer
      }

      const data: VoteData = {
        randomizers,
        selections,
        verificationNumber,
      }
      setVoteData(data)

      // Move private data into document memory and clear URL
      window.history.replaceState(null, '', window.location.pathname)
    } catch (_error) {
      setCheckResult({ error: 'Failed to parse vote data', match: false })
      console.error('Failed to parse vote data', _error)
    }
  }, [election_id, auth_token])

  // Recalculate encrypted vote and send to server
  useEffect(() => {
    if (!voteData || !threshold_public_key || checkResult) return
    ;(async () => {
      if (!ballot_design) return setCheckResult({ error: 'Missing ballot design', match: false })

      try {
        if (!threshold_public_key) return setCheckResult({ error: 'Missing election public key', match: false })

        const public_key = RP.fromHex(threshold_public_key)
        const recalculated: Record<string, CipherStrings> = {}

        const { randomizers, selections, verificationNumber } = voteData

        if (!verificationNumber || !selections || !randomizers)
          return setCheckResult({ error: 'Invalid vote data format', match: false })

        // Recalculate encryption for each selection
        for (const questionId of Object.keys(selections)) {
          // Decode plaintext from compact format (i{index}, b, w:{text}, or as-is)
          const encodedPlaintext = selections[questionId]
          const plaintext = decodePlaintext(encodedPlaintext, questionId, ballot_design)

          // Convert base64url encoded randomizer back to bigint
          const randomizerBigInt = base64URLToBigint(randomizers[questionId])

          // Encode: stringToPoint(`${tracking}:${plaintext}`)
          const encoded = stringToPoint(`${verificationNumber}:${plaintext}`)

          // Encrypt: encrypt(public_key, randomizer, encoded)
          const cipher = encrypt(public_key, randomizerBigInt, encoded)

          // Convert to CipherStrings format
          recalculated[questionId] = {
            encrypted: String(cipher.encrypted),
            lock: String(cipher.lock),
          }
        }

        // Send to API endpoint
        const response = await api('/api/malware-check', {
          auth_token,
          election_id,
          recalculated_encrypted_vote: recalculated,
        })

        const result: CheckResult = await response.json()
        setCheckResult(result)
      } catch (error) {
        setCheckResult({ error: 'Failed to recalculate or verify vote', match: false })
        console.error('Failed to recalculate or verify vote', error)
      }
    })()
  }, [voteData, ballot_design, threshold_public_key, election_id, auth_token, checkResult])

  const columns = useMemo(() => generateColumnNames({ ballot_design }).columns, [ballot_design])

  const handleConfirm = async (confirmed: boolean) => {
    if (!confirmed) return setShowIssueForm(true)

    try {
      const response = await api('/api/malware-check', {
        auth_token,
        confirmed: true,
        election_id,
      })

      if (response.ok) setConfirmed(true)
    } catch (error) {
      // Handle error
      console.error('Failed to report confirmation', error)
    }
  }

  const handleSubmitIssue = async () => {
    try {
      const response = await api('/api/malware-check', {
        auth_token,
        confirmed: false,
        election_id,
        issue_description: issueDescription,
      })

      if (response.ok) {
        setConfirmed(true)
        setShowIssueForm(false)
      }
    } catch (error) {
      // Handle error
      console.error('Failed to submit issue', error)
    }
  }

  if (!voteData || !ballot_design || !threshold_public_key)
    return (
      <div className="p-8 text-center">
        <p>Loading {!voteData ? 'vote data' : !ballot_design ? 'ballot design' : 'public key'}...</p>
      </div>
    )

  if (checkResult?.error)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-red-600">Error</h2>
        <p>{checkResult.error}</p>
      </div>
    )

  if (!checkResult)
    return (
      <div className="p-8 text-center">
        <p>Verifying your vote...</p>
      </div>
    )

  if (confirmed)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-green-600">Thank you</h2>
        <p>Your response has been recorded. You can now close this window.</p>
      </div>
    )

  if (!checkResult.match)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-red-600">⚠️ Vote Mismatch Detected</h2>
        <p className="mb-4">
          The vote recalculated on this device does not match the vote stored on the server. This may indicate malware
          on your original voting device.
        </p>
        <p className="mb-4">
          <strong>Please contact the election administrator immediately.</strong>
        </p>
        <p className="mb-4">The SIV admin has been notified about this issue.</p>
      </div>
    )

  // Show confirmation UI if match
  return (
    <div className="p-8 mx-auto max-w-2xl">
      <h2 className="mb-4 text-xl font-bold">Confirm your selections:</h2>

      <table className="mb-6 w-full border border-gray-300 border-collapse">
        <thead>
          <tr className="bg-gray-100">
            <th className="p-2 text-left border border-gray-300">Question</th>
            <th className="p-2 text-left border border-gray-300">Selection</th>
          </tr>
        </thead>
        <tbody>
          {columns.map((columnId) => {
            const encodedPlaintext = voteData.selections?.[columnId]
            if (!encodedPlaintext) return null

            // Decode plaintext from compact format
            const plaintext = decodePlaintext(encodedPlaintext, columnId, ballot_design || [])
            const displayValue = unTruncateSelection(plaintext, ballot_design || [], columnId)

            // Find question title from ballot design
            const question = ballot_design.find((item) => {
              if (item.id === columnId) return true
              // Handle multi-vote columns like "president_1", "president_2"
              const baseId = columnId.replace(/_\d+$/, '')
              return item.id === baseId
            })

            return (
              <tr key={columnId}>
                <td className="p-2 font-semibold border border-gray-300">{question?.title || columnId}:</td>
                <td className="p-2 border border-gray-300">{plaintext === 'BLANK' ? '' : displayValue}</td>
              </tr>
            )
          })}
        </tbody>
      </table>

      {showIssueForm ? (
        <div className="mb-6">
          <label className="block mb-2 font-semibold">Please describe the issue:</label>
          <textarea
            className="p-2 w-full rounded border border-gray-300"
            onChange={(e) => setIssueDescription(e.target.value)}
            rows={4}
            value={issueDescription}
          />
          <button
            className="px-4 py-2 mt-2 text-white bg-blue-500 rounded hover:bg-blue-600"
            onClick={handleSubmitIssue}
          >
            Submit
          </button>
        </div>
      ) : (
        <div className="mb-6">
          <p className="mb-4">Do these selections match what you intended to vote for?</p>
          <div className="flex gap-4">
            <button
              className="px-6 py-2 text-white bg-green-500 rounded hover:bg-green-600"
              onClick={() => handleConfirm(true)}
            >
              Yes
            </button>
            <button
              className="px-6 py-2 text-white bg-red-500 rounded hover:bg-red-600"
              onClick={() => handleConfirm(false)}
            >
              No
            </button>
          </div>
        </div>
      )}

      {checkResult.device_info && <p className="mt-4 text-sm text-gray-600">Device: {checkResult.device_info}</p>}

      <p className="mt-4 text-xs text-gray-500">
        <strong>Note:</strong> You may be prompted to confirm via SMS to ensure that a live person is performing this
        2nd device check, rather than malware from the original device. If you were given an Anti-Malware Code, please
        have it ready.
      </p>
    </div>
  )
}
