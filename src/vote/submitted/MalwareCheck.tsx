// import { useEffect, useMemo, useState } from 'react'
import { useMemo, useState } from 'react'

import { State } from '../vote-state'
import { encodeBase64URL } from './base64url'
import { MalwareCheckQRCode } from './MalwareCheckQRCode'

type CheckStatus = {
  confirmed: boolean | null
  created_at: null | string
  device_info: string
  match: boolean
  user_agent: string
}

type StatusResponse = {
  checks: CheckStatus[]
  verified_count: number
}

const LOCALHOST_IP = '192.168.4.112'

export const MalwareCheck = ({
  auth,
  election_id,
  state,
}: {
  auth: string
  election_id: string
  state: State & { submitted_at?: Date }
}) => {
  const [isOpen, setIsOpen] = useState(false)
  const [checkStatus] = useState<null | StatusResponse>(null)

  //   // Poll for malware check status
  //   useEffect(() => {
  //     if (!isOpen || !election_id || !auth) return

  //     const fetchStatus = async () => {
  //       try {
  //         const response = await fetch(`/api/election/${election_id}/malware-check-status?auth=${auth}`)
  //         if (response.ok) {
  //           const data: StatusResponse = await response.json()
  //           setCheckStatus(data)
  //         }
  //       } catch {
  //         // Silently fail
  //       }
  //     }

  //     fetchStatus()
  //     const interval = setInterval(fetchStatus, 5000) // Poll every 5 seconds

  //     return () => clearInterval(interval)
  //   }, [isOpen, election_id, auth])

  const qrUrl = useMemo(() => {
    if (!state.tracking || !state.plaintext || !state.randomizer) return ''

    // Build vote data object with shortened keys for compact encoding
    // v = verification_number, s = selections, p = plaintext, r = randomizer
    const voteData: Record<string, unknown> = {
      s: Object.keys(state.plaintext).reduce((acc, questionId) => {
        acc[questionId] = {
          p: state.plaintext[questionId],
          r: state.randomizer[questionId],
        }
        return acc
      }, {} as Record<string, { p: string; r: string }>),
      v: state.tracking,
    }

    // Encode vote data as JSON and base64url encode for hash
    const encodedData = encodeBase64URL(JSON.stringify(voteData))

    // Build URL: siv.org/malware-check/$election_id/$auth_token/#url_encoded_vote_data
    const protocol = typeof window !== 'undefined' && window.location.protocol === 'https:' ? 'https:' : 'http:'
    const host = typeof window !== 'undefined' ? window.location.host.replace('localhost', LOCALHOST_IP) : 'siv.org'
    return `${protocol}//${host}/election/${election_id}/malware-check/${auth}#${encodedData}`
  }, [auth, election_id, state])

  return (
    <div>
      <h3
        className="py-1 mt-6 text-[12px] font-normal text-center text-blue-500 w-fit hover:underline cursor-pointer"
        onClick={() => setIsOpen(!isOpen)}
      >
        [+] Test for Malware
      </h3>
      {isOpen && (
        <div className="flex gap-4 items-center">
          <div className="flex flex-col items-center rounded-md border border-solid w-fit border-black/25">
            <h4 className="mt-4 mb-0 text-sm font-semibold">Scan to Begin</h4>
            {qrUrl ? <MalwareCheckQRCode url={qrUrl} /> : <div className="w-[150px] h-[150px]" />}
          </div>

          <div className="max-w-sm">
            <p className="mb-2">
              As an additional layer of security, you can use multiple&nbsp;devices to verify your vote was submitted as
              intended.
            </p>
            {checkStatus && checkStatus.verified_count > 0 && (
              <p className="mt-2 text-sm text-green-600">
                Verified with {checkStatus.verified_count} separate device{checkStatus.verified_count > 1 ? 's' : ''}
                {checkStatus.checks
                  .filter((c) => c.confirmed === true)
                  .slice(0, 1)
                  .map((c) => ` - ${c.device_info}`)
                  .join(', ')}
              </p>
            )}
          </div>
        </div>
      )}
    </div>
  )
}
