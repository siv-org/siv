// import { useEffect, useMemo, useState } from 'react'
import { useMemo, useState } from 'react'

import { State } from '../vote-state'
import { bigintToBase64URL } from './base64url'
import { MalwareCheckQRCode } from './MalwareCheckQRCode'

type CheckStatus = {
  confirmed: boolean | null
  created_at: null | string
  device_info: string
  match: boolean
  user_agent: string
}

type StatusResponse = {
  checks: CheckStatus[]
  verified_count: number
}

const LOCALHOST_IP = '192.168.4.112'

export const MalwareCheck = ({
  auth,
  election_id,
  state,
}: {
  auth: string
  election_id: string
  state: State & { submitted_at?: Date }
}) => {
  const [isOpen, setIsOpen] = useState(false)
  const [checkStatus] = useState<null | StatusResponse>(null)

  //   // Poll for malware check status
  //   useEffect(() => {
  //     if (!isOpen || !election_id || !auth) return

  //     const fetchStatus = async () => {
  //       try {
  //         const response = await fetch(`/api/election/${election_id}/malware-check-status?auth=${auth}`)
  //         if (response.ok) {
  //           const data: StatusResponse = await response.json()
  //           setCheckStatus(data)
  //         }
  //       } catch {
  //         // Silently fail
  //       }
  //     }

  //     fetchStatus()
  //     const interval = setInterval(fetchStatus, 5000) // Poll every 5 seconds

  //     return () => clearInterval(interval)
  //   }, [isOpen, election_id, auth])

  const qrUrl = useMemo(() => {
    if (!state.randomizer) return ''

    // Build compact format: questionId|randomizer|questionId|randomizer|...
    // Using | as delimiter since it's unlikely to appear in question IDs
    // All characters are URL-safe, so no need for base64url encoding
    const parts: string[] = []

    for (const questionId of Object.keys(state.randomizer)) {
      parts.push(questionId)
      parts.push(bigintToBase64URL(BigInt(state.randomizer[questionId])))
    }

    // Use compact format directly (no base64url encoding needed - all chars are URL-safe)
    const encodedData = parts.join('|')

    // Build URL: siv.org/malware-check/$election_id/$auth_token/#randomizers
    const protocol = typeof window !== 'undefined' && window.location.protocol === 'https:' ? 'https:' : 'http:'
    const host = typeof window !== 'undefined' ? window.location.host.replace('localhost', LOCALHOST_IP) : 'siv.org'
    return `${protocol}//${host}/malware-check/${election_id}/${auth}#${encodedData}`
  }, [auth, election_id, state])

  return (
    <div>
      <h3
        className="py-1 mt-6 text-[12px] font-normal text-center text-blue-500 w-fit hover:underline cursor-pointer"
        onClick={() => setIsOpen(!isOpen)}
      >
        [+] Test for Malware
      </h3>
      {isOpen &&
        (!qrUrl ? (
          <p className="mb-2 text-xs text-black/50">⚠️ QR code not loaded...</p>
        ) : (
          <div className="flex gap-4 items-center">
            <MalwareCheckQRCode url={qrUrl} />

            <div className="max-w-sm">
              <p className="mb-2">
                As an additional layer of security, you can use multiple&nbsp;devices to verify your vote was submitted
                as intended.
              </p>
              <p className="mb-2 text-xs text-black/50">⚠️ This QR contains your private vote selections.</p>
              {checkStatus && checkStatus.verified_count > 0 && (
                <p className="mt-2 text-sm text-green-600">
                  Verified with {checkStatus.verified_count} separate device{checkStatus.verified_count > 1 ? 's' : ''}
                  {checkStatus.checks
                    .filter((c) => c.confirmed === true)
                    .slice(0, 1)
                    .map((c) => ` - ${c.device_info}`)
                    .join(', ')}
                </p>
              )}
            </div>
          </div>
        ))}
    </div>
  )
}
