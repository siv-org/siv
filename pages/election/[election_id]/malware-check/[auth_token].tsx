import { useRouter } from 'next/router'
import { useEffect, useMemo, useState } from 'react'
import { api } from 'src/api-helper'
import { RP, stringToPoint } from 'src/crypto/curve'
import encrypt from 'src/crypto/encrypt'
import { CipherStrings } from 'src/crypto/stringify-shuffle'
import { unTruncateSelection } from 'src/status/un-truncate-selection'
import { generateColumnNames } from 'src/vote/generateColumnNames'

import { ElectionInfo } from '../../../api/election/[election_id]/info'

type CheckResult = {
  device_info?: string
  error?: string
  match: boolean
}

type VoteData = {
  s?: Record<string, { p: string; r: string }> // short for s=selections, p=plaintext, r=randomizer
  v?: string // short for v=verification_number
}

export default function MalwareCheckPage() {
  const router = useRouter()
  const { auth_token, election_id } = router.query
  const [voteData, setVoteData] = useState<null | VoteData>(null)
  const [electionInfo, setElectionInfo] = useState<ElectionInfo | null>(null)
  const [checkResult, setCheckResult] = useState<CheckResult | null>(null)
  const [confirmed, setConfirmed] = useState(false)
  const [issueDescription, setIssueDescription] = useState('')
  const [showIssueForm, setShowIssueForm] = useState(false)

  // Extract vote data from URL hash on page load
  useEffect(() => {
    if (typeof window === 'undefined' || !election_id || !auth_token) return

    const hash = window.location.hash.slice(1) // Remove #
    if (!hash) {
      setCheckResult({ error: 'Missing vote data in URL', match: false })
      return
    }

    try {
      const decoded = decodeURIComponent(hash)
      const data: VoteData = JSON.parse(decoded)
      setVoteData(data)

      // Move private data into document memory and clear URL
      window.history.replaceState(null, '', window.location.pathname)
    } catch (_error) {
      setCheckResult({ error: 'Failed to parse vote data', match: false })
      console.error('Failed to parse vote data', _error)
    }
  }, [election_id, auth_token])

  // Load election info to get public key and ballot design
  useEffect(() => {
    if (!election_id || typeof election_id !== 'string') return
    ;(async () => {
      try {
        const response = await fetch(`/api/election/${election_id}/info`)
        const info: ElectionInfo = await response.json()
        setElectionInfo(info)
      } catch (error) {
        setCheckResult({ error: 'Failed to load election info', match: false })
        console.error('Failed to load election info', error)
      }
    })()
  }, [election_id])

  // Recalculate encrypted vote and send to server
  useEffect(() => {
    if (!voteData || !electionInfo?.threshold_public_key || checkResult) return
    ;(async () => {
      try {
        if (!electionInfo.threshold_public_key)
          return setCheckResult({ error: 'Missing election public key', match: false })

        const public_key = RP.fromHex(electionInfo.threshold_public_key)
        const recalculated: Record<string, CipherStrings> = {}

        // Un-shorten the vote data
        const verificationNumber = voteData.v
        const selections = voteData.s

        if (!verificationNumber || !selections)
          return setCheckResult({ error: 'Invalid vote data format', match: false })

        // Recalculate encryption for each selection
        for (const [questionId, selection] of Object.entries(selections)) {
          const plaintext = selection.p
          const randomizer = selection.r

          // Encode: stringToPoint(`${tracking}:${plaintext}`)
          const encoded = stringToPoint(`${verificationNumber}:${plaintext}`)

          // Encrypt: encrypt(public_key, randomizer, encoded)
          const randomizerBigInt = BigInt(randomizer)
          const cipher = encrypt(public_key, randomizerBigInt, encoded)

          // Convert to CipherStrings format
          recalculated[questionId] = {
            encrypted: String(cipher.encrypted),
            lock: String(cipher.lock),
          }
        }

        // Send to API endpoint
        const response = await fetch('/api/malware-check', {
          body: JSON.stringify({
            auth_token,
            election_id,
            recalculated_encrypted_vote: recalculated,
          }),
          headers: { 'Content-Type': 'application/json' },
          method: 'POST',
        })

        const result: CheckResult = await response.json()
        setCheckResult(result)
      } catch (error) {
        setCheckResult({ error: 'Failed to recalculate or verify vote', match: false })
        console.error('Failed to recalculate or verify vote', error)
      }
    })()
  }, [voteData, electionInfo, election_id, auth_token, checkResult])

  const columns = useMemo(() => {
    if (!electionInfo?.ballot_design) return []
    return generateColumnNames({ ballot_design: electionInfo.ballot_design }).columns
  }, [electionInfo])

  const handleConfirm = async (confirmed: boolean) => {
    if (!confirmed) {
      setShowIssueForm(true)
      return
    }

    try {
      const response = await api('/api/malware-check', {
        auth_token,
        confirmed: true,
        election_id,
      })

      if (response.ok) setConfirmed(true)
    } catch (error) {
      // Handle error
      console.error('Failed to report confirmation', error)
    }
  }

  const handleSubmitIssue = async () => {
    try {
      const response = await api('/api/malware-check', {
        auth_token,
        confirmed: false,
        election_id,
        issue_description: issueDescription,
      })

      if (response.ok) {
        setConfirmed(true)
        setShowIssueForm(false)
      }
    } catch (error) {
      // Handle error
      console.error('Failed to submit issue', error)
    }
  }

  if (!voteData || !electionInfo)
    return (
      <div className="p-8 text-center">
        <p>Loading...</p>
      </div>
    )

  if (checkResult?.error)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-red-600">Error</h2>
        <p>{checkResult.error}</p>
      </div>
    )

  if (!checkResult)
    return (
      <div className="p-8 text-center">
        <p>Verifying your vote...</p>
      </div>
    )

  if (confirmed)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-green-600">Thank you</h2>
        <p>Your response has been recorded. You can now close this window.</p>
      </div>
    )

  if (!checkResult.match)
    return (
      <div className="p-8">
        <h2 className="mb-4 font-bold text-red-600">⚠️ Vote Mismatch Detected</h2>
        <p className="mb-4">
          The vote recalculated on this device does not match the vote stored on the server. This may indicate malware
          on your original voting device.
        </p>
        <p className="mb-4">
          <strong>Please contact the election administrator immediately.</strong>
        </p>
        <p className="mb-4">The SIV admin has been notified about this issue.</p>
      </div>
    )

  // Show confirmation UI if match
  return (
    <div className="p-8 mx-auto max-w-2xl">
      <h2 className="mb-4 text-xl font-bold">Confirm your selections:</h2>

      <table className="mb-6 w-full border border-gray-300 border-collapse">
        <thead>
          <tr className="bg-gray-100">
            <th className="p-2 text-left border border-gray-300">Question</th>
            <th className="p-2 text-left border border-gray-300">Selection</th>
          </tr>
        </thead>
        <tbody>
          {columns.map((columnId) => {
            const selection = voteData.s?.[columnId]
            if (!selection) return null

            const plaintext = selection.p
            const displayValue = unTruncateSelection(plaintext, electionInfo.ballot_design || [], columnId)

            // Find question title from ballot design
            const question = electionInfo.ballot_design?.find((item) => {
              if (item.id === columnId) return true
              // Handle multi-vote columns like "president_1", "president_2"
              const baseId = columnId.replace(/_\d+$/, '')
              return item.id === baseId
            })

            return (
              <tr key={columnId}>
                <td className="p-2 font-semibold border border-gray-300">{question?.title || columnId}:</td>
                <td className="p-2 border border-gray-300">{plaintext === 'BLANK' ? '' : displayValue}</td>
              </tr>
            )
          })}
        </tbody>
      </table>

      {showIssueForm ? (
        <div className="mb-6">
          <label className="block mb-2 font-semibold">Please describe the issue:</label>
          <textarea
            className="p-2 w-full rounded border border-gray-300"
            onChange={(e) => setIssueDescription(e.target.value)}
            rows={4}
            value={issueDescription}
          />
          <button
            className="px-4 py-2 mt-2 text-white bg-blue-500 rounded hover:bg-blue-600"
            onClick={handleSubmitIssue}
          >
            Submit
          </button>
        </div>
      ) : (
        <div className="mb-6">
          <p className="mb-4">Do these selections match what you intended to vote for?</p>
          <div className="flex gap-4">
            <button
              className="px-6 py-2 text-white bg-green-500 rounded hover:bg-green-600"
              onClick={() => handleConfirm(true)}
            >
              Yes
            </button>
            <button
              className="px-6 py-2 text-white bg-red-500 rounded hover:bg-red-600"
              onClick={() => handleConfirm(false)}
            >
              No
            </button>
          </div>
        </div>
      )}

      {checkResult.device_info && <p className="mt-4 text-sm text-gray-600">Device: {checkResult.device_info}</p>}

      <p className="mt-4 text-xs text-gray-500">
        <strong>Note:</strong> You may be prompted to confirm via SMS to ensure that a live person is performing this
        2nd device check, rather than malware from the original device. If you were given an Anti-Malware Code, please
        have it ready.
      </p>
    </div>
  )
}
