import { NextApiRequest, NextApiResponse } from 'next'
import { CipherStrings } from 'src/crypto/stringify-shuffle'

import { firebase, pushover } from '../_services'

export default async (req: NextApiRequest, res: NextApiResponse) => {
  const { already_seen_device, auth_token, election_id, otp } = req.body

  if (typeof election_id !== 'string') return res.status(400).json({ error: 'Missing election_id' })
  if (typeof auth_token !== 'string') return res.status(400).json({ error: 'Missing auth_token' })
  if (typeof otp !== 'string') return res.status(400).json({ error: 'Missing otp' })

  const electionDoc = firebase.firestore().collection('elections').doc(election_id)
  const checkDoc = electionDoc.collection('malware-checks').doc(auth_token)

  const check = await checkDoc.get()
  if (!check.exists) {
    await pushover('Malware check not found', `${election_id}: ${auth_token}\nOTP: ${otp}`)
    return res.status(404).json({ error: 'No malware check found' })
  }

  const data = check.data()
  if (!data || !data.checks || !Array.isArray(data.checks)) return res.status(404).json({ error: 'Invalid check data' })

  // Find matching check entry by OTP
  const checkEntry = data.checks.find((entry: { otp?: string }) => entry.otp === otp)
  if (!checkEntry) {
    await pushover('Malware check: Invalid OTP', `${election_id}: ${auth_token}\nOTP: ${otp}`)
    return res.status(401).json({ error: 'Invalid OTP' })
  }

  // Check if already downloaded
  if (checkEntry.downloaded_at) {
    await pushover('Malware check: Already downloaded', `${election_id}: ${auth_token}\nOTP: ${otp}`)
    return res.status(410).json({ error: 'Already downloaded. Restart from original device' })
  }

  // Fetch encrypted vote from database
  const votes = await electionDoc.collection('votes').where('auth', '==', auth_token).get()
  if (votes.empty) return res.status(404).json({ error: 'Vote not found' })

  const storedVote = votes.docs[0].data()
  const storedEncryptedVote = storedVote.encrypted_vote as Record<string, CipherStrings>

  // Update the specific check entry
  const updatedChecks = data.checks.map((entry: { already_seen_device?: null | string; otp?: string }) => {
    if (entry.otp === otp)
      return {
        ...entry,
        already_seen_device: already_seen_device ?? null,
        downloaded_at: new Date(),
        downloaded_by_ip: req.headers['x-real-ip'] || null,
        downloaded_by_user_agent: req.headers['user-agent'] || null,
      }

    return entry
  })

  await checkDoc.update({ checks: updatedChecks })

  return res.status(200).json({
    encrypted_randomizers: checkEntry.encrypted_randomizers,
    encrypted_vote: storedEncryptedVote,
  })
}
