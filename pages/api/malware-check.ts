import { firestore } from 'firebase-admin'
import { NextApiRequest, NextApiResponse } from 'next'

// import { firebase, pushover } from './_services'
import { firebase } from './_services'
import { generateEmailLoginCode } from './admin-login'

export default async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' })

  const { auth_token, confirmed, decrypted, election_id, issue_description } = req.body

  if (typeof election_id !== 'string') return res.status(400).json({ error: 'Missing election_id' })
  if (typeof auth_token !== 'string') return res.status(400).json({ error: 'Missing auth_token' })

  const electionDoc = firebase.firestore().collection('elections').doc(election_id)

  // If this is a confirmation submission (after match)
  if (confirmed !== undefined) {
    const checkDoc = electionDoc.collection('malware-checks').doc(auth_token)
    const check = await checkDoc.get()
    if (!check.exists) return res.status(404).json({ error: 'No malware check found' })

    await checkDoc.update({
      confirmations: firestore.FieldValue.arrayUnion({
        confirmed,
        confirmed_at: new Date(),
        issue_description: issue_description || null,
        otp: req.body.otp || null,
      }),
    })

    return res.status(200).json({ success: true })
  }

  // Otherwise, this is the initial check request

  // Generate a 6-digit OTP to match the device against later.
  const otp = generateEmailLoginCode()

  // Store device info in malware-checks subcollection
  await electionDoc
    .collection('malware-checks')
    .doc(auth_token)
    .set(
      {
        auth: auth_token,
        decrypted: firestore.FieldValue.arrayUnion({
          created_at: new Date(),
          decrypted,
          device_info: req.headers['user-agent'] || null,
          otp,
        }),
      },
      { merge: true },
    )

  // Send Pushover notification to admin on mismatch
  // if (!match)
  //   await pushover(
  //     'SIV Malware Check Mismatch',
  //     `election: ${election_id}\nauth: ${auth_token}\ndevice: ${deviceInfo}\nVoter's recalculated vote does not match the stored vote.`,
  //   )

  return res.status(200).json({ otp })
}
