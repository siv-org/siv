import { firestore } from 'firebase-admin'
import { NextApiRequest, NextApiResponse } from 'next'
import { CipherStrings } from 'src/crypto/stringify-shuffle'

// import { firebase, pushover } from './_services'
import { firebase } from './_services'

export default async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' })

  const { auth_token, confirmed, election_id, issue_description, recalculated_encrypted_vote } = req.body

  if (typeof election_id !== 'string') return res.status(400).json({ error: 'Missing election_id' })
  if (typeof auth_token !== 'string') return res.status(400).json({ error: 'Missing auth_token' })

  const electionDoc = firebase.firestore().collection('elections').doc(election_id)

  // If this is a confirmation submission (after match)
  if (confirmed !== undefined) {
    const checkDoc = electionDoc.collection('malware-checks').doc(auth_token)
    const check = await checkDoc.get()

    if (!check.exists) return res.status(404).json({ error: 'No malware check found' })

    await checkDoc.update({
      confirmed,
      confirmed_at: firestore.FieldValue.serverTimestamp(),
      issue_description: issue_description || null,
    })

    return res.status(200).json({ success: true })
  }

  // Otherwise, this is the initial check request
  if (!recalculated_encrypted_vote) return res.status(400).json({ error: 'Missing recalculated_encrypted_vote' })

  // Fetch stored vote from database
  const votes = await electionDoc.collection('votes').where('auth', '==', auth_token).get()
  if (votes.empty) return res.status(404).json({ error: 'Vote not found', match: false })

  const storedVote = votes.docs[0].data()
  const storedEncryptedVote = storedVote.encrypted_vote as Record<string, CipherStrings>

  // Compare recalculated encrypted vote with stored encrypted vote
  const match = compareEncryptedVotes(storedEncryptedVote, recalculated_encrypted_vote)

  // Get device info
  const userAgent = req.headers['user-agent'] || 'Unknown'
  const deviceInfo = parseUserAgent(userAgent)

  // Store device info in malware-checks subcollection
  const checkData = {
    auth: auth_token,
    confirmed: null as boolean | null,
    created_at: firestore.FieldValue.serverTimestamp(),
    device_info: {
      device_type: deviceInfo,
      timestamp: firestore.FieldValue.serverTimestamp(),
      user_agent: userAgent,
    },
    issue_description: null as null | string,
    match,
    recalculated_vote: recalculated_encrypted_vote,
  }

  await electionDoc.collection('malware-checks').doc(auth_token).set(checkData)

  // Send Pushover notification to admin on mismatch
  // if (!match)
  //   await pushover(
  //     'SIV Malware Check Mismatch',
  //     `election: ${election_id}\nauth: ${auth_token}\ndevice: ${deviceInfo}\nVoter's recalculated vote does not match the stored vote.`,
  //   )

  return res.status(200).json({
    device_info: deviceInfo,
    match,
  })
}

function compareEncryptedVotes(
  stored: Record<string, CipherStrings>,
  recalculated: Record<string, CipherStrings>,
): boolean {
  // Check if all keys match
  const storedKeys = Object.keys(stored).sort()
  const recalculatedKeys = Object.keys(recalculated).sort()

  if (storedKeys.length !== recalculatedKeys.length) return false

  // Compare each cipher
  for (const key of storedKeys) {
    if (!recalculated[key]) return false

    const storedCipher = stored[key]
    const recalculatedCipher = recalculated[key]

    // Compare encrypted and lock values
    if (storedCipher.encrypted !== recalculatedCipher.encrypted) return false
    if (storedCipher.lock !== recalculatedCipher.lock) return false
  }

  return true
}

function parseUserAgent(userAgent: string): string {
  // Simple user agent parsing for device type
  const ua = userAgent.toLowerCase()

  if (ua.includes('iphone')) return 'iPhone'
  if (ua.includes('ipad')) return 'iPad'
  if (ua.includes('android')) return 'Android'
  if (ua.includes('windows')) return 'Windows'
  if (ua.includes('mac')) return 'Mac'
  if (ua.includes('linux')) return 'Linux'

  // Extract browser info
  if (ua.includes('safari') && !ua.includes('chrome')) return 'Safari'
  if (ua.includes('chrome')) return 'Chrome'
  if (ua.includes('firefox')) return 'Firefox'
  if (ua.includes('edge')) return 'Edge'

  return 'Unknown Device'
}
